
# Collections

This document contains some brief diagrams to help aid the understanding of
important state changes within the collection's code and the impact those
state changes have on persistence and DCP.

## Collection state change diagram

The following diagram shows a collections lifetime when stimuli occurs. The
stimuli are new JSON Collections::Manifests being applied to the
Collections::VB::Manifest.  For example a new manifest with a previously unknown
collection triggers entry into the state diagram, a manifest that now omits a
known collection would move the known collection to exclusive deleting.


Collections state changes:
```
               ●
               │┌────────────────────────┐
               ├┤ Collection is created  │
               │└────────────────────────┘
               ▼
          .─────────.
         /           \
        :    open     :
         \           /
           ─────────
               │
               │
               │
               │┌────────────────────────┐
               ├┤ Collection is deleted  │
               │└────────────────────────┘
               ▼
         .─────────.
        /           \
       :  deleting   :
        \           /
          ─────────
               │
               │
               │
               │┌───────────────────────────┐
               ├┤ Collection is completely  │
               ││deleted (all items removed)│
               │└───────────────────────────┘
               ●
```

## State diagram with SystemEvents

The same state diagram is now annotated to show the SystemEvents that are
generated by each state change.

A SystemEvent is a 'special' Item owned by the server, but queued into the
user's data stream. The SystemEvent allows the flusher and DCP to trigger
specific actions that will be ordered with the user's data stream.

A SystemEvent can be created and for some use-cases, deleted. For collections
the end of a collection is denoted by a deleted Collection event.

```
                                  ●
                                  │
         ┌───────────────────────┐│
         │      Collection       ├┤
         └───────────────────────┘▼
                             .─────────.
                            /           \
                           :    open     :
                            \           /
                              ─────────
                                  │
                                  │
                                  │
                                  │
        ┌────────────────────────┐│
        │  Collection [deleted]  ├┤
        └────────────────────────┘▼
                            .─────────.
                           /           \
                          :  deleting   :
                           \           /
                             ─────────
                                  │
                                  │
                                  │
                                  │
                                  ●
```

## Collection States and Sequence Numbers

A collection's state is determined by the sequence numbers assigned to the
collection.

For example, when a collection is created we record the sequence number at which
we queue the create SystemEvent. And when a collection is deleted we record the
sequence number at which we queue the delete SystemEvent. This gives us a
sequence number life-span of each collection.

* Each collection has a `start_seqno` and an `end_seqno`.
* The `end_seqno` is permitted to have a special value of -6, this value means there is no end.

### Determining states from the seqno start/end:
* Open
  * `end_seqno == -6`
* Deleting
  * `end_seqno != -6`

## VBucket JSON manifest

The code refers to a serialised JSON VB manifest. This is a persisted copy of
the VB::Manifest which can be used to recover a VBucket's collection state
following a restart.

The VB::Manifest is also recording the sequence number of the system-events and
uses those values to track a collection's life time. A VBucket JSON manifest
looks like the following (although we don't store a white space formatted
document).

```
{
   "collections":[
      {"uid":"0","start_seqno":"1","end_seqno":"-6"},
      {"uid":"1","start_seqno":"13012","end_seqno":"-6"},
    ]
}
```

## SystemEvents

The SystemEvents are represented by the Item object. We weave SystemEvents into
the Checkpoint allowing DCP and the Flusher to see the event and then respond to
it, or ignore it. A SystemEvent Item can also be marked as deleted which
collections utilises for marking the logical delete of a collection.

A SystemEvent is a special case of Item and is identified primarily by the
operation member being set to "queue_op::system_event". The type of the
SystemEvent is stored in the flags field as an int.

### SystemEvent Identification

Consider a collection with an id of 0x4c456771 (this is an ID deliberately in the printable ascii range):

* Creating the collection generates the following Item.
  * event = `SystemEvent::Collection`, key = `$collection:LEgq`, deleted = false
* Logically deleting the fruit collection generates the following Item.
  * event = `SystemEvent::Collection`, key = `$collection:LEgq`, deleted = true

### SystemEvent flushing actions

SystemEvents are treated differently by the flusher.

* `Collection`
  * Sets or Deletes a document called `$collection:LEgq` with a value that at least contains the UID
  * Updates the `_local/collections_manifest` (A JSON copy of the VB::Manifest)

### SystemEvent DCP actions

SystemEvents are treated differently by the ActiveStream.

* `Collection`
  * `!isDeleted` Sends DcpSystem event message containing mcbp::CreateCollection, `value="manifest-uid, collection-ID"`
  * `isDeleted` Sends DcpSystem event message containing mcbp::DeleteCollection, `value="manifest-uid, collection-ID"`

## Examples

### create/delete

1. Start with `0=open`
2. Receive (assume VB high-seqno is 200)

   `{"collections":[{"name":"$default", "uid":"0"}, {"name":"fruit","uid":"4c456771"}]}`

  * `0=open, 4c456771=open`
  * stores a document `$collection:LEgq` at seqno 201
  * _local/collections_manifest
   ```
  {"collections":[
      {"uid":"0","start_seqno":"1","end_seqno":"-6"},
      {"uid":"4c456771","start_seqno":"201","end_seqno":"-6"}]}
   ```
3. Receive (assume VB high-seqno is now 430)

   `{"collections":[{"name":"$default", "uid":"0"}]}`

  * `0=open, 4c456771=deleting`
  * note the creation of a deleted(SystemEvent::Collection) will trigger a background erase of the collection's items.
  * _local/collections_manifest
   ```
  {"collections":[
      {"uid":"0","start_seqno":"1","end_seqno":"-6"},
      {"uid":"4c456771","start_seqno":"201","end_seqno":"431"}]}
   ```
4. When the background delete of 4c456771 is complete and assuming VB high-seqno is now 561

  * `0=open`
  * _local/collections_manifest (now 4c456771 is deleted 'hard')
   ```
  {"collections":[
      {"uid":"0","start_seqno":"1","end_seqno":"-6"}]}
   ```

## Deleting a collection

Deleting a collection begins by the VB::Manifest deleting the `SystemEvent::Collection`
that was originally written when the collection was created. The seqno of this
deletion is recorded in the collection's entry as the end seqno. The items of the
collection still exist, but now they are termed 'logically deleted'.

The items of the collection are now removed from the system by the compactor.

The compactor initialises a VB::Manifest from the datafile's _local manifest, thus
the compactor makes decisions about item deletion consistently with the datafile.

As the kvstore compactor iterates the bySeqno index it will decide if the key@seqno
should be discarded, this is asking it's VB::Manifest if the item `isLogicallyDeleted`.
If a key has a seqno which is in the deleted range (less than the start or end seqno)
it is discarded from the database.

A collection is considered fully deleted when the compactor finally encounters
the collection's deleted marker, the assumption being we must of visited all items
that could of been in the collection, so the collection is now empty.

On encountering the deleted marker the compactor updates:
* The in-memory VB::Manifest to erase the collection entry (freeing a small amount of resource)
* The compaction owned VB::Manifest to erase the collection entry, ready for the final stage

The final stage of compaction is now to update the _local collection metadata by
serialising the compaction owned VB::Manifest into a flatbuffer format, the serialised
data will not contain any of the fully dropped collections, making the metadata
consistent with the data.

The actual delete marker will be removed by tombstone purging (e.g. 3 days later)
this ensures any DCP clients which were disconnected can reconnect to the VB and
for 3 days still discover that the collection was dropped After 3 days, the
marker is purged and the purge-seqno blocks those clients who are now inconsistent
with the database.
