
# Collections

This document contains some brief diagrams to help aid the understanding of
important state changes within the collection's code and the impact those
state changes have on persistence and DCP.

## Collection state change diagram

The following diagram shows a collections lifetime when stimuli occurs. The
stimuli are new JSON Collections::Manifests being applied to the
Collections::VB::Manifest.  For example a new manifest with a previously unknown
collection triggers entry into the state diagram, a manifest that now omits a
known collection would move the known collection to exclusive deleting.


Collections state changes:
```
               ●
               │┌────────────────────────┐
               ├┤ Collection is created  │
               │└────────────────────────┘
               ▼
          .─────────.
         /           \
        :    open     :
         \           /
           ─────────
               │
               │
               │
               │┌────────────────────────┐
               ├┤ Collection is deleted  │
               │└────────────────────────┘
               ▼
         .─────────.
        /           \
       :  deleting   :
        \           /
          ─────────
               │
               │
               │
               │┌───────────────────────────┐
               ├┤ Collection is completely  │
               ││deleted (all items removed)│
               │└───────────────────────────┘
               ●
```

## State diagram with SystemEvents

The same state diagram is now annotated to show the SystemEvents that are
generated by each state change.

A SystemEvent is a 'special' Item owned by the server, but queued into the
user's data stream. The SystemEvent allows the flusher and DCP to trigger
specific actions that will be ordered with the user's data stream.

A SystemEvent can be created and for some use-cases, deleted. For collections
the end of a collection is denoted by a deleted Collection event.

```
                                  ●
                                  │
         ┌───────────────────────┐│
         │      Collection       ├┤
         └───────────────────────┘▼
                             .─────────.
                            /           \
                           :    open     :
                            \           /
                              ─────────
                                  │
                                  │
                                  │
                                  │
        ┌────────────────────────┐│
        │  Collection [deleted]  ├┤
        └────────────────────────┘▼
                            .─────────.
                           /           \
                          :  deleting   :
                           \           /
                             ─────────
                                  │
                                  │┌────────────────────────┐
                                  ├┤  DeleteCollectionHard  │
                                  │└────────────────────────┘
                                  │
                                  │
                                  ●
```

## Collection States and Sequence Numbers

A collection's state is determined by the sequence numbers assigned to the
collection.

For example, when a collection is created we record the sequence number at which
we queue the create SystemEvent. And when a collection is deleted we record the
sequence number at which we queue the delete SystemEvent. This gives us a
sequence number life-span of each collection.

* Each collection has a `start_seqno` and an `end_seqno`.
* The `end_seqno` is permitted to have a special value of -6, this value means there is no end.

### Determining states from the seqno start/end:
* Open
  * `end_seqno == -6`
* Deleting
  * `end_seqno != -6`

## VBucket JSON manifest

The code refers to a serialised JSON VB manifest. This is a persisted copy of
the VB::Manifest which can be used to recover a VBucket's collection state
following a restart.

The VB::Manifest is also recording the sequence number of the system-events and
uses those values to track a collection's life time. A VBucket JSON manifest
looks like the following (although we don't store a white space formatted
document).

```
{
   "collections":[
      {"uid":"0","start_seqno":"1","end_seqno":"-6"},
      {"uid":"1","start_seqno":"13012","end_seqno":"-6"},
    ]
}
```

## SystemEvents

The SystemEvents are represented by the Item object. We weave SystemEvents into
the Checkpoint allowing DCP and the Flusher to see the event and then respond to
it, or ignore it. A SystemEvent Item can also be marked as deleted which
collections utilises for marking the logical delete of a collection.

A SystemEvent is a special case of Item and is identified primarily by the
operation member being set to "queue_op::system_event". The type of the
SystemEvent is stored in the flags field as an int.

### SystemEvent Identification

Consider a collection with an id of 0x4c456771 (this is an ID deliberately in the printable ascii range):

* Creating the collection generates the following Item.
  * event = `SystemEvent::Collection`, key = `$collection:LEgq`, deleted = false
* Logically deleting the fruit collection generates the following Item.
  * event = `SystemEvent::Collection`, key = `$collection:LEgq`, deleted = true
* If all data of a collection is deleted
  * event = `SystemEvent::DeleteCollectionHard`, key = `$collection:LEgq`, deleted = false

### SystemEvent flushing actions

SystemEvents are treated differently by the flusher.

* `Collection`
  * Sets or Deletes a document called `$collection:LEgq` with a value that at least contains the UID
  * Updates the `_local/collections_manifest` (A JSON copy of the VB::Manifest)
* `DeleteCollectionHard`
  * Updates the `_local/collections_manifest` (A JSON copy of the VB::Manifest) so that the collection's metadata is all gone

### SystemEvent DCP actions

SystemEvents are treated differently by the ActiveStream.

* `Collection`
  * `!isDeleted` Sends DcpSystem event message containing mcbp::CreateCollection, `value="manifest-uid, collection-ID"`
  * `isDeleted` Sends DcpSystem event message containing mcbp::DeleteCollection, `value="manifest-uid, collection-ID"`
* `DeleteCollectionHard`
  * Ignored by DCP

## Examples

### create/delete

1. Start with `0=open`
2. Receive (assume VB high-seqno is 200)

   `{"collections":[{"name":"$default", "uid":"0"}, {"name":"fruit","uid":"4c456771"}]}`

  * `0=open, 4c456771=open`
  * stores a document `$collection:LEgq` at seqno 201
  * _local/collections_manifest
   ```
  {"collections":[
      {"uid":"0","start_seqno":"1","end_seqno":"-6"},
      {"uid":"4c456771","start_seqno":"201","end_seqno":"-6"}]}
   ```
3. Receive (assume VB high-seqno is now 430)

   `{"collections":[{"name":"$default", "uid":"0"}]}`

  * `0=open, 4c456771=deleting`
  * note the creation of a deleted(SystemEvent::Collection) will trigger a background erase of the collection's items.
  * _local/collections_manifest
   ```
  {"collections":[
      {"uid":"0","start_seqno":"1","end_seqno":"-6"},
      {"uid":"4c456771","start_seqno":"201","end_seqno":"431"}]}
   ```
4. When the background delete of 4c456771 is complete and assuming VB high-seqno is now 561

  * `0=open`
  * _local/collections_manifest (now 4c456771 is deleted 'hard')
   ```
  {"collections":[
      {"uid":"0","start_seqno":"1","end_seqno":"-6"}]}
   ```
